package demo.domain;

import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import demo.json.OptionalListOfStringDeserializer;

import java.io.File;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.Duration;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.OptionalInt;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static java.nio.charset.StandardCharsets.UTF_8;
import static java.util.Objects.requireNonNull;

@JsonTypeName("Command")
public record Command(List<String> commands,
                      Optional<Duration> shouldFinishWithin,
                      Optional<Boolean> shouldFail,
                      Optional<List<String>> onFailureCommands,
                      Optional<List<String>> finallyCommands,
                      Optional<Path> workingDir,
                      Optional<CommandOutput> output,
                      Optional<List<String>> tags,
                      Optional<List<String>> comments,
                      OptionalInt indent) implements Entry {

    @Override
    public Result run() {
        final List<Stream<String>> streams = new ArrayList<>(7);
        streams.add(Stream.of("```shell"));
        streams.add(formatCommandsToRunAsStream(this.commands()));
        streams.add(Stream.of("```"));

        boolean error = false;
        if (!skipCommandExecution()) {
            final ShellScriptResult shellScriptResult = runCommands();

            if (shellScriptResult.hasFailed()) {
                runOnFailureCommands();
            }

            if (shellScriptResult.hasFailed() != shouldFailOrDefault()) {
                streams.add(Stream.of("", "_Unexpected Outcome_ (Command exit code: " + shellScriptResult.exitCode() + ")", "", "```"));
                streams.add(shellScriptResult.readOutput());
                streams.add(Stream.of("```"));
                error = true;
            } else {
                shouldPrintOutput(shellScriptResult).ifPresent(header -> {
                    streams.add(Stream.of(""));
                    streams.add(header.stream());
                    streams.add(Stream.of("", "```" + outputOrDefault().contentTypeOrDefault()));
                    streams.add(shellScriptResult.readOutput());
                    streams.add(Stream.of("```"));
                });
            }
        }

        final String output = streams.stream()
                .flatMap(Function.identity())
                .map(line -> line.concat("\n"))
                .map(indentLines())
                .collect(Collectors.joining());

        return error
                ? Result.error(output)
                : Result.ok(output);
    }

    private boolean skipCommandExecution() {
        return tags.map(t -> t.contains("skip"))
                .orElse(false);
    }

    @Override
    public void runFinally() {
        finallyCommandsFailureCommandsAsShellScript().ifPresent(commands -> {
            final Path script = writeShellScriptToFile(commands);
            runShellScript(script, DEFAULT_TIMEOUT);
        });
    }

    private String commandsAsShellScript() {
        final String header = """
                #!/bin/sh
                
                # Generated by the Sociable Weaver application
                # This file is automatically deleted once the execution completes
                
                set -e
                
                """;

        return header + formatCommandsToRun(commands);
    }

    private Optional<String> onFailureCommandsAsShellScript() {
        return onFailureCommands.map(commands -> {
            final String header = """
                    #!/bin/sh
                    
                    # Generated by the Sociable Weaver application
                    # This file is automatically deleted once the execution completes
                    # All commands in the script are executed even when a previous command fails as this is intended for clean up
                    
                    """;

            return header + formatCommandsToRun(commands);
        });
    }

    private Optional<String> finallyCommandsFailureCommandsAsShellScript() {
        return finallyCommands.map(commands -> {
            final String header = """
                    #!/bin/sh
                    
                    # Generated by the Sociable Weaver application
                    # This file is automatically deleted once the execution completes
                    # All commands in the script are executed even when a previous command fails as this is intended for clean up
                    
                    """;

            return header + formatCommandsToRun(commands);
        });
    }

    private Optional<List<String>> shouldPrintOutput(final ShellScriptResult shellScriptResult) {
        if (shellScriptResult.hasFailed() || outputOrDefault().showOrDefault()) {
            return Optional.of(outputOrDefault().captionOfDefault());
        }

        return Optional.empty();
    }

    private Function<String, String> indentLines() {
        return indent.isEmpty()
                ? Function.identity()
                : line -> line.isBlank() ? line : (" ".repeat(indent.getAsInt())).concat(line);
    }

    private String formatCommandsToRun(final List<String> commandsToRun) {
        return formatCommandsToRunAsStream(commandsToRun)
                .map(line -> line.concat("\n"))
                .collect(Collectors.joining());
    }

    private Stream<String> formatCommandsToRunAsStream(final List<String> commands) {
        final List<Stream<String>> list = new ArrayList<>(3);

        if (workingDir.isPresent()) {
            final Path path = workingDir.get();
            list.add(Stream.of("# Running command from within the '" + path + "' directory",
                    "(cd '" + path + '\''));
            list.add(commands.stream());
            list.add(Stream.of(")"));
        } else {
            list.add(commands.stream());
        }

        return list.stream()
                .flatMap(Function.identity());
    }

    private boolean shouldFailOrDefault() {
        return shouldFail.orElse(false);
    }

    private CommandOutput outputOrDefault() {
        return output.orElse(DEFAULT_COMMAND_OUTPUT);
    }

    private Duration shouldFinishWithinOrDefault() {
        return shouldFinishWithin.orElse(DEFAULT_TIMEOUT);
    }

    private ShellScriptResult runCommands() {
        final String commands = commandsAsShellScript();
        final Path script = writeShellScriptToFile(commands);
        return runShellScript(script, shouldFinishWithinOrDefault());
    }

    private Optional<ShellScriptResult> runOnFailureCommands() {
        return onFailureCommandsAsShellScript()
                .map(Command::writeShellScriptToFile)
                /* TODO: What should be the timeout of the cleanup commands? */
                .map(script -> runShellScript(script, Duration.ofMinutes(10)));
    }

    private static Path writeShellScriptToFile(final String script) {
        final Path path = findNonExistingFile();

        try {
            Files.writeString(path, script, UTF_8);

            final File file = path.toFile();
            file.deleteOnExit();

            if (!file.setExecutable(true)) {
                throw new RuntimeException("Failed to make the script executable");
            }
        } catch (final IOException e) {
            throw new UncheckedIOException("Failed to write script to file", e);
        }

        return path;
    }

    private ShellScriptResult runShellScript(final Path script, final Duration timeout) {
        final Path outputFile = script.toAbsolutePath().getParent().resolve(script.getFileName() + ".out");
        outputFile.toFile().deleteOnExit();

        try {
            final Process process = new ProcessBuilder(script.toAbsolutePath().toString())
                    .redirectOutput(outputFile.toFile())
                    .redirectErrorStream(true)
                    .start();
            final boolean finished = process.waitFor(timeout.toMillis(), java.util.concurrent.TimeUnit.MILLISECONDS);
            if (!finished) {
                process.destroyForcibly();
                process.waitFor();
                return new ShellScriptResult(-1, outputFile);
            }

            final int exitCode = process.exitValue();
            return new ShellScriptResult(exitCode, outputFile);
        } catch (final InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException("Interrupted while running the commands", e);
        } catch (final IOException e) {
            throw new UncheckedIOException("Failed to run the commands", e);
        }
    }

    private static Path findNonExistingFile() {
        final DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyyMMdd-HHmmss-SSS");
        final String prefix = ".sw-command-" + LocalDateTime.now().format(formatter);

        Path path = Path.of(prefix + ".sh");
        for (int i = 1; Files.isRegularFile(path); i++) {
            path = Path.of(prefix + '-' + i + ".sh");
        }

        return path;
    }

    private record ShellScriptResult(int exitCode, Path output) {

        ShellScriptResult {
            requireNonNull(output);
        }

        public Stream<String> readOutput() {
            try {
                return Files.lines(output, UTF_8);
            } catch (final IOException e) {
                throw new UncheckedIOException("Failed to read the commands output", e);
            }
        }

        public boolean hasFailed() {
            return exitCode != 0;
        }
    }

    public record CommandOutput(Optional<Boolean> show,
                                @JsonDeserialize(using = OptionalListOfStringDeserializer.class)
                                Optional<List<String>> caption,
                                Optional<String> contentType) {

        public CommandOutput {
            requireNonNull(show);
            requireNonNull(caption);
            requireNonNull(contentType);

            caption = caption.map(List::copyOf);
        }

        public boolean showOrDefault() {
            return show.orElse(true);
        }

        public List<String> captionOfDefault() {
            return caption.orElse(DEFAULT_CAPTION);
        }

        public String contentTypeOrDefault() {
            return contentType.orElse("");
        }

        private static final List<String> DEFAULT_CAPTION = List.of("_Output_");
    }

    private static final CommandOutput DEFAULT_COMMAND_OUTPUT = new CommandOutput(
            Optional.of(false),
            Optional.empty(),
            Optional.empty());

    private static final Duration DEFAULT_TIMEOUT = Duration.ofMinutes(1);
}
